#version 330

// Input
in vec2 texture_coord;

// Uniform properties
uniform sampler2D textureImage;
uniform ivec2 screenSize;
uniform int flipVertical;
uniform int outputMode = 2; // 0: original, 1: grayscale, 2: blur

// Output
layout(location = 0) out vec4 out_color;

// Local variables
vec2 textureCoord = vec2(texture_coord.x, (flipVertical != 0) ? 1 - texture_coord.y : texture_coord.y); // Flip texture


vec4 grayscale()
{
    vec4 color = texture(textureImage, textureCoord);
    float gray = 0.21 * color.r + 0.71 * color.g + 0.07 * color.b; 
    return vec4(gray, gray, gray,  0);
}


vec4 blur(int blurRadius)
{
    vec2 texelSize = 1.0f / screenSize;
    vec4 sum = vec4(0);
    for(int i = -blurRadius; i <= blurRadius; i++)
    {
        for(int j = -blurRadius; j <= blurRadius; j++)
        {
            sum += texture(textureImage, textureCoord + vec2(i, j) * texelSize);
        }
    }
        
    float samples = pow((2 * blurRadius + 1), 2);
    return sum / samples;
}

vec4 sobel()
{
    vec2 texelSize = 1.0 / screenSize;

    // Kernel Sobel pentru X și Y
    mat3 kernelX = mat3(
        -1,  0,  1,
        -2,  0,  2,
        -1,  0,  1
    );

    mat3 kernelY = mat3(
        -1, -2, -1,
         0,  0,  0,
         1,  2,  1
    );

    float gx = 0.0;
    float gy = 0.0;

    // Aplicarea kernel-urilor Sobel
    for (int i = -1; i <= 1; i++) {
        for (int j = -1; j <= 1; j++) {
            vec4 color = texture(textureImage, textureCoord + vec2(i, j) * texelSize);
            float gray = 0.21 * color.r + 0.71 * color.g + 0.07 * color.b;

            gx += kernelX[i + 1][j + 1] * gray;
            gy += kernelY[i + 1][j + 1] * gray;
        }
    }

    // Magnitudinea gradientului
    float magnitude = sqrt(gx * gx + gy * gy);

    return vec4(magnitude, magnitude, magnitude, 1.0);
}

vec4 binarize(float threshold)
{
    vec4 sobelColor = sobel(); // Apelăm Sobel
    float value = sobelColor.r;

    if (value > threshold)
        return vec4(1.0, 1.0, 1.0, 1.0); // Alb
    else
        return vec4(0.0, 0.0, 0.0, 1.0); // Negru
}



// Median filter function
vec4 median(int radius)
{
    vec2 texelSize = 1.0f / screenSize;
    const int MAX_RADIUS = 3; // Change this if needed, but should not exceed the maximum supported by GLSL
    const int size = (2 * MAX_RADIUS + 1) * (2 * MAX_RADIUS + 1);
    vec4 samples[size];
    int index = 0;

    // Sample all the neighboring texels
    for(int i = -radius; i <= radius; i++)
    {
        for(int j = -radius; j <= radius; j++)
        {
            samples[index] = texture(textureImage, textureCoord + vec2(i, j) * texelSize);
            index++;
        }
    }

    // Sort the colors by their intensity (grayscale value)
    for (int i = 0; i < size - 1; i++) 
    {
        for (int j = i + 1; j < size; j++) 
        {
            float intensityA = 0.21 * samples[i].r + 0.71 * samples[i].g + 0.07 * samples[i].b;
            float intensityB = 0.21 * samples[j].r + 0.71 * samples[j].g + 0.07 * samples[j].b;

            // Swap if necessary
            if (intensityA > intensityB) 
            {
                vec4 temp = samples[i];
                samples[i] = samples[j];
                samples[j] = temp;
            }
        }
    }

    // Return the median (middle) value
    return samples[size / 2];
}


void main()
{
    switch (outputMode)
    {
        case 1:
        {
            out_color = grayscale();
            break;
        }

        case 2:
        {
            out_color = blur(3);
            break;
        }

        case 3:
        {
            out_color = median(3);
            break;
        }

        case 4:
        {
            vec4 gray = grayscale();
            vec4 blurred = blur(3);
            vec4 sobelResult = sobel();
            vec4 binaryResult = binarize(0.3);

            // Alegem rezultatul final (se poate schimba în funcție de scenariu)
            out_color = binaryResult;
            break;
        }

        default:
            out_color = texture(textureImage, textureCoord);
            break;
    }
}
